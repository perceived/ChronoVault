/**
	BitmaskUtility:
		Has utility methods to use with bitmasks.
	Author(s):
		Ryan Scott Clark
	Date Created:
		08-07-2016
	Date Last Modified:
		07-24-2017
	Attach Script to:
		
	Notes:
		
	Change log:
		07-21-2017:	Stripped version of full BitmaskUtility for posting with the Enum devlog.
		07-24-2017:	Functions now use long as a parameter, so that they'll work for 1 << 31 (max entry value of int-based mask).
					Changed isPowerOfTwo so that it works for negative values, using twos-complement.
	To do:
		
	Bugs:
		
**/

using System;
using System.Collections.Generic;
using UnityEngine;

namespace ChronoVault {

	public static class BitmaskUtility {

		/// <summary>
		///		Stores power of two values with the key of their indices.
		///		Generated by GetMaskIndex.
		/// </summary>
		private static Dictionary<long, int> storedReverseBitShifts = new Dictionary<long, int>();



		/// <summary>
		///		Returns a List of indices corresponding to values contained in a bitmask (by index, 0 to maxCount - 1).
		/// </summary>
		/// <param name="bitmask"></param>
		/// <param name="maxCount">
		///		The maximum count to use for the bitmask.  Only used if the bitmask's value is negative, since we can't determine what the max count is.
		///		Useful for when using a bitmask with a known maximum entries count, such as an enum.
		///	</param>
		/// <returns></returns>
		public static List<int> GetBitmaskIndices(long bitmask, int maxCount = 32) {

			List<int> values = new List<int>();

			int i = 0;
			int val;

			while (bitmask != 0 && i < maxCount) {
				//	Make the layer into a mask
				val = 1 << i;

				//	If the mask contains val
				if ((bitmask & val) != 0) {
					//	Remove from the bitmask
					bitmask = bitmask & ~(bitmask & val);
					values.Add(i);
				}
				i++;
			}

			return values;
		}

		/// <summary>
		///		Returns a List of values contained in a bitmask.
		/// </summary>
		/// <param name="bitmask"></param>
		/// <param name="maxCount">
		///		The maximum count to use for the bitmask.  Only used if the bitmask's value is negative, since we can't determine what the max count is.
		///		Useful for when using a bitmask with a known maximum entries count, such as an enum.
		///	</param>
		/// <returns></returns>
		public static List<int> GetBitmaskValues(long bitmask, int maxCount = 32) {

			List<int> values = new List<int>();

			int i = 0;
			int val;

			while (bitmask != 0 && i < maxCount) {
				//	Make the layer into a mask
				val = 1 << i;

				//	If the mask contains val
				if ((bitmask & val) != 0) {
					//	Remove from the bitmask
					bitmask = bitmask & ~(bitmask & val);
					values.Add(val);
				}
				i++;
			}

			return values;
		}

		/// <summary>
		///		Returns whether the provided value is a power of two.
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public static bool isPowerOfTwo(long value) {

			return value < 0
				//	If negative, convert value to positive representation using 2s complement
				? (~(value - 1) & (~(value - 1) - 1)) == 0
				: (value & (value - 1)) == 0;
		}

		/// <summary>
		///		Gets the index that corresponds to a power of two value (non-combined bitmask).
		/// </summary>
		/// <exception cref="ArgumentException">Passed value is not a power of two.</exception>
		/// <param name="value">A non-combined bitmask value.</param>
		/// <returns></returns>
		public static int GetMaskIndex(long value) {

			if (!isPowerOfTwo(value))
				throw new ArgumentException("Passed value \"" + value.ToString() + "\" is not a power of two.");

			int index;
			if (!storedReverseBitShifts.TryGetValue(value, out index)) {
				index = (int) Math.Log(value, 2);
				storedReverseBitShifts.Add(value, index);
			}
			return index;
		}
	}
}