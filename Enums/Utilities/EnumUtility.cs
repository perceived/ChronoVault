/**
	EnumUtility:
		Contains static utility functions for enums.  Enum extensions are still contained in the Extensions class.
	Author(s):
		Ryan Scott Clark
	Date Created:
		08-07-2016
	Date Last Modified:
		07-07-2017
	Attach Script to:
		
	Notes:
		None of these methods are intended for use in enums that are based higher than Int32.
	Change log:
		08-24-2016:	Added versions that take Type instead of a generic parameter.
					Added GetValues.
					For GetDescriptions, if no description is present, now has the option to use user-friendly text as a fallback.
		06-06-2017:	Added DoesMaskHaveMultiple.
		06-08-2017:	Added Increment and Decrement.
					Added Reorder.
					Added GetMaskIndex.
					Optimized GetValues and GetDescriptions by adding caching.
					Moved in all Enum Extensions from Extensions.
		06-12-2017:	Added isDefined.
					Added isValid.
		06-14-2017:	Completed refactor.  Rewrote all methods to be optimized, added Generic constraints and Type checking, added use of dictionaries, and renamed (or removed) methods.
		07-07-2017:	Added All.
	To do:
		
	Bugs:
		
**/

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
#if !UNITY_IOS
using System.Reflection;
#endif
using UnityEngine;

namespace ChronoVault {

	public static class EnumUtility {

		/// <summary>
		///		Stores Enum.GetValues in Array form.
		///		Generated by GetList, GetCollection.
		/// </summary>
		private static Dictionary<Type, Array> storedValuesArray = new Dictionary<Type, Array>();

		/// <summary>
		///		Stores Enum.GetValues in List of int form.
		///		Generated by GetValues.
		/// </summary>
		private static Dictionary<Type, List<int>> storedValues = new Dictionary<Type, List<int>>();

		/// <summary>
		///		Stores the Description attribute.
		///		Generated by GetDescriptions.
		/// </summary>
		private static Dictionary<Type, List<string>> storedDescriptions = new Dictionary<Type, List<string>>();

		/// <summary>
		///		Stores the presence of the Flags attribute.
		///		Generated by isFlaggedType.
		/// </summary>
		private static Dictionary<Type, bool> storedIsFlaggedType = new Dictionary<Type, bool>();



		#region Enum Type methods
		/// <summary>
		///		Provides a List of all the defined enums for an enum Type.
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static List<T> GetList<T>() where T : struct, IConvertible {

			if (!typeof(T).IsEnum)
				throw new ArgumentException("Passed T \"" + typeof(T).ToString() + "\" is not an enum.");

			Array array;
			if (!storedValuesArray.TryGetValue(typeof(T), out array)) {
				array = Enum.GetValues(typeof(T));
				storedValuesArray.Add(typeof(T), array);
			}
			return new List<T>((T[]) array);
		}

		/// <summary>
		///		Provides a collection of all the defined enums for an enum Type.
		/// </summary>
		/// <exception cref="ArgumentException">Passed Type is not an enum.</exception>
		/// <param name="enumType"></param>
		/// <returns></returns>
		public static IEnumerable<Enum> GetCollection(Type enumType) {

			if (!enumType.IsEnum)
				throw new ArgumentException("Passed Type \"" + enumType.ToString() + "\" is not an enum.");

			Array array;
			if (!storedValuesArray.TryGetValue(enumType, out array)) {
				array = Enum.GetValues(enumType);
				storedValuesArray.Add(enumType, array);
			}
			return array.Cast<Enum>();
		}

		/// <summary>
		///		Provides a List of all the enums' int values for an enum Type.
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static List<int> GetValues<T>() where T : struct, IConvertible {

			return GetValues(typeof(T));
		}

		/// <summary>
		///		Provides a List of all the enums' int values for an enum Type.
		/// </summary>
		/// <exception cref="ArgumentException">Passed Type is not an enum.</exception>
		/// <param name="enumType"></param>
		/// <returns></returns>
		public static List<int> GetValues(Type enumType) {

			if (!enumType.IsEnum)
				throw new ArgumentException("Passed Type \"" + enumType.ToString() + "\" is not an enum.");

			return new List<int>(GetValuesInternal(enumType));
		}

		/// <summary>
		///		Provides a List of all the enums' int values for an enum Type.
		///		NOTE: This is the internal method, which does not perform a Type check and does not return a copy of the List.
		/// </summary>
		/// <param name="enumType"></param>
		/// <returns></returns>
		private static List<int> GetValuesInternal(Type enumType) {

			List<int> values;
			if (!storedValues.TryGetValue(enumType, out values)) {
				values = new List<int>((int[]) Enum.GetValues(enumType));
				storedValues.Add(enumType, values);
			}
			return values;
		}

		/// <summary>
		///		Determines if the provided enum type is a flagged enum (checks for the presence of the FlagsAttribute).
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static bool isFlaggedType<T>() where T : struct, IConvertible {

			return isFlaggedType(typeof(T));
		}

		/// <summary>
		///		Determines if the provided enum type is a flagged enum (checks for the presence of the FlagsAttribute).
		/// </summary>
		/// <exception cref="ArgumentException">Passed Type is not an enum.</exception>
		/// <param name="enumType"></param>
		/// <param name="debug"></param>
		/// <returns></returns>
		public static bool isFlaggedType(Type enumType, bool debug = false) {

			if (!enumType.IsEnum)
				throw new ArgumentException("Passed Type \"" + enumType.ToString() + "\" is not an enum.");

			bool isFlagged;
			if (!storedIsFlaggedType.TryGetValue(enumType, out isFlagged)) {
				isFlagged = enumType.GetAttribute<FlagsAttribute>() != null;
				storedIsFlaggedType.Add(enumType, isFlagged);
			}
			return isFlagged;
		}

		/// <summary>
		///		Returns a list of enum Descriptions (using the System.ComponentModel.DescriptionAttribute), ordered by index in the enum.
		///		NOTE: This will preserve duplicate entries (multiple enum entries mapped to the same value), unlike Enum.GetDescription().
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="userFriendlyAsFallback">
		///		If true, uses a user-friendly text format if there is no description.  See FormatUtility.GetUserFriendlyText.
		///		If false, will hold null.
		///	</param>
		/// <returns></returns>
		public static List<string> GetDescriptions<T>(bool userFriendlyAsFallback = true) where T : struct, IConvertible {

			return GetDescriptions(typeof(T), userFriendlyAsFallback);
		}

		/// <summary>
		///		Returns a list of enum Descriptions (using the System.ComponentModel.DescriptionAttribute), ordered by index in the enum.
		///		NOTE: This will preserve duplicate entries (multiple enum entries mapped to the same value), unlike Enum.GetDescription().
		/// </summary>
		/// <exception cref="ArgumentException">Passed Type is not an enum.</exception>
		/// <param name="enumType"></param>
		/// <param name="userFriendlyAsFallback">
		///		If true, uses a user-friendly text format if there is no description.  See FormatUtility.GetUserFriendlyText.
		///	</param>
		/// <returns></returns>
		public static List<string> GetDescriptions(Type enumType, bool userFriendlyAsFallback = true) {

			if (!enumType.IsEnum)
				throw new ArgumentException("Passed Type \"" + enumType.ToString() + "\" is not an enum.");

			List<string> names;
			if (!storedDescriptions.TryGetValue(enumType, out names)) {
				names = new List<string>(Enum.GetNames(enumType));

				#if !UNITY_IOS
				FieldInfo field;

				for (int i = 0; i < names.Count; i++) {
					field = (enumType).GetField(names[i]);
					DescriptionAttribute attr = Attribute.GetCustomAttribute(field, typeof(DescriptionAttribute)) as DescriptionAttribute;
					if (attr != null)
						names[i] = attr.Description;
					else if (userFriendlyAsFallback)
						names[i] = FormatUtility.GetUserFriendlyText(names[i]);
				}
				#else

				if (userFriendlyAsFallback)
					for (int i = 0; i < names.Count; i++)
						names[i] = FormatUtility.GetUserFriendlyText(names[i]);
				#endif

				storedDescriptions.Add(enumType, names);
			}
			return new List<string>(names);
		}
		#endregion

		#region Enum Sequence methods
		/// <summary>
		///		Returns a reordered List of the provided enum, with the startIndex being moved to the front.
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <exception cref="ArgumentOutOfRangeException">Passed startIndex exceeded the enum's bounds.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="startIndex"></param>
		/// <returns></returns>
		public static List<T> Reorder<T>(int startIndex) where T : struct, IConvertible {

			if (!typeof(T).IsEnum)
				throw new ArgumentException("Passed T \"" + typeof(T).ToString() + "\" is not an enum.");

			List<T> enumList = GetList<T>();
			if (!enumList.WithinBounds(startIndex))
				throw new ArgumentOutOfRangeException("Passed startIndex \"" + startIndex + "\" exceeded the enum's bounds.");

			enumList.MoveRange(startIndex, enumList.Count - startIndex, 0);
			return enumList;
		}

		/// <summary>
		///		Returns a reordered List of the provided enum, with the startEnum being moved to the front.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between startEnum and T.</exception>
		/// <exception cref="ArgumentException">Passed startEnum did not match an index in the enum's list.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="startEnum"></param>
		/// <returns></returns>
		public static List<T> Reorder<T>(Enum startEnum) where T : struct, IConvertible {

			if (startEnum.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + startEnum.GetType() + "\" and T \"" + typeof(T) + "\".");

			List<T> enumList = GetList<T>();

			int startIndex = enumList.IndexOf((T) (object) startEnum);
			if (startIndex == -1)
				throw new ArgumentException("Passed startEnum \"" + startEnum.ToString() + "\" did not match an index in the enum's list.");

			enumList.MoveRange(startIndex, enumList.Count - startIndex, 0);
			return enumList;
		}
		#endregion

		#region Enum Validation methods
		/// <summary>
		///		Determines if the passed value directly matches an enum value.
		///		NOTE: Will return false if the passed enum contains multiple masked values.  For that, use isValid instead.
		///		NOTE: A cached version similar to Enum.IsDefined.
		/// </summary>
		/// <param name="enumValue"></param>
		/// <returns></returns>
		public static bool isDefined(Enum enumValue) {

			return GetValuesInternal(enumValue.GetType()).Contains((int) (object) enumValue);
		}

		/// <summary>
		///		Determines if the passed value directly matches one of the values.
		/// </summary>
		/// <param name="value"></param>
		/// <param name="values"></param>
		/// <returns></returns>
		private static bool isDefinedInternal(int value, List<int> values) {

			return values.Contains(value);
		}

		/// <summary>
		///		Determines if the passed value directly matches an enum value or is a valid combined mask (if the enum is a flagged type).
		/// </summary>
		/// <param name="enumValue"></param>
		/// <returns></returns>
		public static bool isValid(Enum enumValue) {

			int value = (int) (object) enumValue;
			List<int> values = GetValuesInternal(enumValue.GetType());

			//	Test if defined first, then if not check if the enum is a flagged type, and if so check if it's a combined value
			return isDefinedInternal(value, values)
				|| (isFlaggedType(enumValue.GetType()) && isCombinedValueInternal(value, values));
		}

		/// <summary>
		///		Determines if a value is a combined value using a list of power of two values.
		/// </summary>
		/// <param name="value">The value to test whether it exists solely from non-repeated power of twos contained in values.</param>
		/// <param name="values">Power of two values to test from.</param>
		/// <returns></returns>
		private static bool isCombinedValueInternal(int value, List<int> values) {

			//	Iterate over all values, reducing the enumValue until 0 is reached
			for (int i = values.Count - 1; i >= 0; i--) {
				if (value < values[i])
					continue;
				value -= values[i];
				if (value == 0)
					return true;
			}
			//	Otherwise return false, since the value isn't defined or part of a combined mask
			return false;
		}
		#endregion

		#region Enum Bitmask and Operator methods
		/// <summary>
		///		Returns a collection of all of the enums within a flag enum.  Unlike GetFlags(), this will cast to the given enum type.
		///		If empty, collection has no values.
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <returns></returns>
		public static IEnumerable<T> GetFlags<T>(this Enum value) where T : struct, IConvertible {

			if (!typeof(T).IsEnum)
				throw new ArgumentException("Passed Type \"" + typeof(T).ToString() + "\" is not an enum.");

			return value.GetFlags().Cast<T>();
		}

		/// <summary>
		///		Returns a collection of all of the enums within a flag enum.
		///		If empty, collection has no values.
		///		NOTE: If the enum has elements with the same value, these will be duplicated in the returned collection.
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public static IEnumerable<Enum> GetFlags(this Enum value) {

			foreach (Enum flag in GetCollection(value.GetType()))
				if (value.HasFlag(flag))
					yield return flag;
		}

		/// <summary>
		///		Given an enum, returns the first flag present.  If no flag is present, returns null.
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public static Enum GetFirstFlag(this Enum value) {

			IEnumerable<Enum> flags = GetFlags(value);
			if (flags == null)
				return null;
			return flags.First();
		}

		/// <summary>
		///		Given an enum, returns the last flag present.  If no flag is present, returns null.
		/// </summary>
		/// <param name="value"></param>
		/// <returns></returns>
		public static Enum GetLastFlag(this Enum value) {

			IEnumerable<Enum> flags = GetFlags(value);
			if (flags == null)
				return null;
			return flags.Max();
		}

		/// <summary>
		///		Returns true if a bitmasked enum contains another enum of the same type.
		///		Mimics the 4.0 HasFlag method, and is the same as Contains.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and flag.</exception>
		/// <param name="enumValue">The tested enum.</param>
		/// <param name="flag">The flag to test.</param>
		/// <returns>True if the flag is set. Otherwise false.</returns>
		public static bool HasFlag(this Enum enumValue, Enum flag) {

			if (enumValue.GetType() != flag.GetType())
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and flag \"" + flag.GetType() + "\".");

			int num = (int) (object) flag;
			return ((int) (object) enumValue & num) == num;
		}

		/// <summary>
		///		Returns true if a bitmasked enum contains another enum (or int).
		///		Mimics the 4.0 HasFlag method.
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum or int.</exception>
		/// <typeparam name="T">Either an enum or int.</typeparam>
		/// <param name="total">Enum to check containing within.</param>
		/// <param name="value">Enum to check if contained within Total.  Can also be a bitmasked enum.</param>
		/// <returns>bool; If enum or int, returns if the Total contains the Value.  Otherwise, returns false.</returns>
		public static bool Contains<T>(this T total, T value) where T : struct, IConvertible {

			if (!typeof(T).IsEnum && typeof(T) != typeof(int))
				throw new ArgumentException("Passed T \"" + typeof(T) + "\" is not an enum or int.");

			int valueInt = CastTo<int>.From<T>(value);
			return (valueInt & CastTo<int>.From<T>(total)) == valueInt;
		}

		/// <summary>
		///		Determines if there are any overlaps between two enums (works for both being bitmasked flag enums).
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum or int.</exception>
		/// <typeparam name="T">Either an enum or int.</typeparam>
		/// <param name="enum1">Enum to check containing within.</param>
		/// <param name="enum2"></param>
		/// <returns></returns>
		public static bool ContainsAny<T>(this T enum1, T enum2) where T : struct, IConvertible {

			if (!typeof(T).IsEnum && typeof(T) != typeof(int))
				throw new ArgumentException("Passed T \"" + typeof(T) + "\" is not an enum or int.");

			return (CastTo<int>.From<T>(enum1) & CastTo<int>.From<T>(enum2)) != 0;
		}

		/// <summary>
		///		Creates a mask that shares the layers of two masks.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue"></param>
		/// <param name="flag"></param>
		public static T Union<T>(this Enum enumValue, T flag) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");

			return CastTo<T>.From<int>((int) (object) enumValue | CastTo<int>.From<T>(flag));
		}

		/// <summary>
		///		Creates a mask that shares the layers of two masks.
		///		Syntactic sugar for Union.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <param name="flag"></param>
		public static T Add<T>(this Enum value, T flag) where T : struct, IConvertible {

			return Union(value, flag);
		}

		/// <summary>
		///		Creates a mask without the indicated layers, if any are present.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue"></param>
		/// <param name="flag"></param>
		public static T Remove<T>(this Enum enumValue, T flag) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");

			return CastTo<T>.From<int>((int) (object) enumValue & ~CastTo<int>.From<T>(flag));
		}

		/// <summary>
		///		Creates a mask that contains only the layers shared between two masks.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue"></param>
		/// <param name="flag"></param>
		public static T Intersection<T>(this Enum enumValue, T flag) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");

			return CastTo<T>.From<int>((int) (object) enumValue & CastTo<int>.From<T>(flag));
		}

		/// <summary>
		///		Creates a mask that contains only the layers shared between two masks.
		///		Syntactic sugar for Intersection.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue"></param>
		/// <param name="flag"></param>
		public static T SharedBetween<T>(this Enum enumValue, T flag) where T : struct, IConvertible {

			return Intersection(enumValue, flag);
		}

		/// <summary>
		///		Creates a mask that contains only the layers not shared between two masks.
		///		NOTE: Is not the same as Remove!
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue"></param>
		/// <param name="flag"></param>
		public static T Difference<T>(this Enum enumValue, T flag) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");
			
			return CastTo<T>.From<int>((int) (object) enumValue ^ CastTo<int>.From<T>(flag));
		}

		/// <summary>
		///		Creates a mask that contains only the layers not shared between two masks.
		///		NOTE: Is not the same as Remove!
		///		Syntactic sugar for Difference.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="value"></param>
		/// <param name="flag"></param>
		public static T NotInCommon<T>(this Enum value, T flag) where T : struct, IConvertible {

			return Difference(value, flag);
		}

		/// <summary>
		///		Increments an enum to the next available value.
		///		NOTE: Throws an exception if a combined enum is passed.  Check DoesMaskHaveMultiple first.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <exception cref="ArgumentException">Passed enumValue cannot be a combined enum.</exception>
		/// <exception cref="ArgumentOutOfRangeException">"Passed enumValue incremented beyond its range.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue">The enum to use.</param>
		/// <param name="loopAround">Should a value incremented beyond its bounds loop around?  If false, throws an ArgumentOutOfRangeException if bounds are exceeded.</param>
		/// <returns></returns>
		public static T Increment<T>(Enum enumValue, bool loopAround = true) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");

			if (isFlaggedType<T>() && DoesMaskHaveMultiple(enumValue))
				throw new ArgumentException("Passed enumValue \"" + enumValue.ToString() + "\" cannot be a combined enum.");

			List<int> values = GetValuesInternal(enumValue.GetType());
			int index = values.IndexOf((int) (object) enumValue);

			if (index < values.Count - 1)
				return CastTo<T>.From<int>(values[index + 1]);
			else if (loopAround)
				return CastTo<T>.From<int>(values[0]);
			throw new ArgumentOutOfRangeException("enumValue", "Passed enumValue \"" + enumValue.ToString() + "\" incremented beyond its range.");
		}

		/// <summary>
		///		Increments an enum to the next available value.  The generic version should be used instead, if possible.
		///		NOTE: Throws an exception if a combined enum is passed.  Check DoesMaskHaveMultiple first.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">"Passed enumValue incremented beyond its range.</exception>
		/// <param name="enumValue"></param>
		/// <param name="loopAround"></param>
		/// <returns></returns>
		public static int Increment(Enum enumValue, bool loopAround = true) {

			List<int> values = GetValuesInternal(enumValue.GetType());
			int index = values.IndexOf((int) (object) enumValue);

			if (index < values.Count - 1)
				return values[index + 1];
			else if (loopAround)
				return values[0];
			throw new ArgumentOutOfRangeException("enumValue", "Passed enumValue \"" + enumValue.ToString() + "\" incremented beyond its range.");
		}

		/// <summary>
		///		Decrements an enum to the previous available value.
		///		NOTE: Throws an exception if a combined enum is passed.  Check isFlaggedType and DoesMaskHaveMultiple first.
		/// </summary>
		/// <exception cref="ArgumentException">Type mismatch between enumValue and T.</exception>
		/// <exception cref="ArgumentException">Passed enumValue cannot be a combined enum.</exception>
		/// <exception cref="ArgumentOutOfRangeException">"Passed enumValue decremented beyond its range.</exception>
		/// <typeparam name="T"></typeparam>
		/// <param name="enumValue">The enum to use.</param>
		/// <param name="loopAround">Should a value decremented beyond its bounds loop around?  If false, throws an ArgumentOutOfRangeException if bounds are exceeded.</param>
		/// <returns></returns>
		public static T Decrement<T>(Enum enumValue, bool loopAround = true) where T : struct, IConvertible {

			if (enumValue.GetType() != typeof(T))
				throw new ArgumentException("Type mismatch between enumValue \"" + enumValue.GetType() + "\" and T \"" + typeof(T) + "\".");

			if (isFlaggedType<T>() && DoesMaskHaveMultiple(enumValue))
				throw new ArgumentException("Passed enumValue \"" + enumValue.ToString() + "\" cannot be a combined enum.");

			List<int> values = GetValuesInternal(enumValue.GetType());
			int index = values.IndexOf((int) (object) enumValue);

			if (index > 0)
				return CastTo<T>.From<int>(values[index - 1]);
			else if (loopAround)
				return CastTo<T>.From<int>(values[values.Count - 1]);
			throw new ArgumentOutOfRangeException("enumValue", "Passed enumValue \"" + enumValue.ToString() + "\" decremented beyond its range.");
		}

		/// <summary>
		///		Decrements an enum to the previous available value.
		///		NOTE: Throws an exception if a combined enum is passed.  Check isFlaggedType and DoesMaskHaveMultiple first.
		/// </summary>
		/// <exception cref="ArgumentOutOfRangeException">"Passed enumValue decremented beyond its range.</exception>
		/// <param name="enumValue"></param>
		/// <param name="loopAround"></param>
		/// <returns></returns>
		public static int Decrement(Enum enumValue, bool loopAround = true) {

			List<int> values = GetValuesInternal(enumValue.GetType());
			int index = values.IndexOf((int) (object) enumValue);

			if (index > 0)
				return values[index - 1];
			else if (loopAround)
				return values[values.Count - 1];
			throw new ArgumentOutOfRangeException("enumValue", "Passed enumValue \"" + enumValue.ToString() + "\" decremented beyond its range.");
		}

		/// <summary>
		///		Gets the index that corresponds to a non-combined bitmask value.
		/// </summary>
		/// <exception cref="ArgumentException">Passed enumValue cannot be a combined enum.</exception>
		/// <param name="enumValue">A non-combined enum mask value.</param>
		/// <returns></returns>
		public static int GetMaskIndex(Enum enumValue) {

			return BitmaskUtility.GetMaskIndex((int) (object) enumValue);
		}

		/// <summary>
		///		Does the provided enum mask have multiple flagged values (is not a power of two)?
		/// </summary>
		/// <param name="bitmask"></param>
		/// <returns></returns>
		public static bool DoesMaskHaveMultiple(Enum bitmask) {

			return !BitmaskUtility.isPowerOfTwo((int) (object) bitmask);
		}

		/// <summary>
		///		Does the provided enum mask have multiple flagged values (is not a power of two)?
		/// </summary>
		/// <param name="bitmask"></param>
		/// <returns></returns>
		public static bool DoesMaskHaveMultiple(int bitmask) {

			return !BitmaskUtility.isPowerOfTwo(bitmask);
		}

		/// <summary>
		///		Returns an enum mask that contains all the entry values (casts ~0).
		/// </summary>
		/// <exception cref="ArgumentException">Passed T is not an enum.</exception>
		/// <typeparam name="T"></typeparam>
		/// <returns></returns>
		public static T All<T>() where T : struct, IConvertible {
			
			if (!typeof(T).IsEnum)
				throw new ArgumentException("Passed T \"" + typeof(T) + "\" is not an enum or int.");

			return CastTo<T>.From<int>(~0);
		}
		#endregion

		#region Enum Attribute methods
		/// <summary>
		///		Gets the description from an enum (using System.ComponentModel to utilize the DescriptionAttribute and System.Reflection to get the Attribute's value).
		///		For iOS (or for the case of no Description attribute), defaults to the string value of the enum.
		///		NOTE: Is not able to differentiate between two enum entries that share the same value.
		///			If differentiation is required, use EnumUtility.GetDescriptions() instead.
		/// </summary>
		/// <param name="enumValue">The enum to return a Description for.</param>
		/// <param name="userFriendlyAsFallback">If true, uses a user-friendly text format if there is no description.  See FormatUtility.GetUserFriendlyText.</param>
		/// <returns>string, either being the description, a user-friendly fallback, or the ToString representation.</returns>
		public static string GetDescription(this Enum enumValue, bool userFriendlyAsFallback = true) {

			#if !UNITY_IOS
			Type type = enumValue.GetType();
			string name = Enum.GetName(type, enumValue);
			if (name != null) {
				FieldInfo field = type.GetField(name);
				if (field != null) {
					System.ComponentModel.DescriptionAttribute attr = Attribute.GetCustomAttribute(field, typeof(System.ComponentModel.DescriptionAttribute)) as System.ComponentModel.DescriptionAttribute;
					if (attr != null)
						return attr.Description;
				}
			}
			#endif

			if (userFriendlyAsFallback)
				return FormatUtility.GetUserFriendlyText(enumValue.ToString());
			return enumValue.ToString();
		}

		/// <summary>
		///		Returns custom attribute classes on enums.
		/// </summary>
		/// <typeparam name="TAttribute">The Attribute class to return.</typeparam>
		/// <param name="enumValue">The enum to get the attribute from.</param>
		/// <returns></returns>
		public static TAttribute GetAttribute<TAttribute>(this Enum enumValue) where TAttribute : Attribute {

			Type type = enumValue.GetType();
			return type.GetField(Enum.GetName(type, enumValue))
				.GetCustomAttributes(false)
				.OfType<TAttribute>()
				.SingleOrDefault();
		}
		#endregion



		#region Other Extension methods
		/// <summary>
		///		Returns the first matching Attribute for a Type.  If the passed Attribute is not present, returns null.
		/// </summary>
		/// <exception cref="ArgumentNullException">Passed type was null.</exception>
		/// <typeparam name="TAttribute"></typeparam>
		/// <param name="type"></param>
		/// <param name="includeInherited"></param>
		/// <returns></returns>
		public static TAttribute GetAttribute<TAttribute>(this Type type, bool includeInherited = false) where TAttribute : Attribute {

			if (type == null)
				throw new ArgumentNullException("type");

			return type.GetCustomAttributes(typeof(TAttribute), includeInherited).FirstOrDefault() as TAttribute;
		}

		/// <summary>
		///		Handles a List null reference and out of bounds check, all in one.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list"></param>
		/// <param name="index"></param>
		/// <returns>bool; false if List is null or Index exceeds bounds, true otherwise.</returns>
		public static bool WithinBounds<T>(this IList<T> list, int index) {

			return list == null ? false : index < list.Count && index >= 0;
		}

		/// <summary>
		///		Moves a range of elements to the target index.
		///		NOTE: If elements from an earlier part of the list are being moved to the later, the targetIndex won't match the element originating at startIndex.
		/// </summary>
		/// <typeparam name="T"></typeparam>
		/// <param name="list">The list to move elements for.</param>
		/// <param name="startIndex">The index to start moving from.</param>
		/// <param name="count">The count of elements to move.</param>
		/// <param name="targetIndex">The index to move to.</param>
		public static void MoveRange<T>(this IList<T> list, int startIndex, int count, int targetIndex) {

			if (startIndex == targetIndex || count == 0)
				return;

			T item;
			for (int i = count - 1; i >= 0; i--) {
				item = list[startIndex + i];
				list.RemoveAt(startIndex + i);
				if (targetIndex > startIndex + i)
					targetIndex--;

				list.Insert(targetIndex, item);
				if (startIndex > targetIndex)
					startIndex++;
			}
		}
		#endregion
	}
}